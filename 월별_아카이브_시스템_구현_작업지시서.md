# 월별 아카이브 시스템 구현 작업지시서

## 📋 프로젝트 개요

### 목표
- 기존 자산관리 시스템에 월별 데이터 조회/수정 기능 추가
- 현재 데이터와 과거 아카이브 데이터를 하나의 인터페이스에서 관리
- **기존 기능 100% 보존** (덧붙이기 방식)

### 핵심 원칙
- 기존 테이블/코드 변경 금지
- 새로운 테이블과 API로 아카이브 기능 구현
- 점진적, 단계별 구현으로 리스크 최소화

## 🗄️ 데이터베이스 설계

### 새로운 테이블 생성 (기존 테이블 보존)

```sql
-- 월별 아카이브 메인 테이블
CREATE TABLE monthly_archives (
    id INT PRIMARY KEY AUTO_INCREMENT,
    archive_month DATE NOT NULL COMMENT '아카이브 월 (YYYY-MM-01)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    modification_notes TEXT COMMENT '수정 사유/내역',

    UNIQUE KEY unique_month (archive_month),
    INDEX idx_archive_month (archive_month)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 범용 자산 아카이브 데이터
CREATE TABLE assets_archive_data (
    id INT PRIMARY KEY AUTO_INCREMENT,
    archive_id INT NOT NULL,
    asset_table ENUM('cash_assets', 'investment_assets', 'pension_assets') NOT NULL,
    asset_data JSON NOT NULL COMMENT '원본 테이블 데이터 완전 보존',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (archive_id) REFERENCES monthly_archives(id) ON DELETE CASCADE,
    INDEX idx_archive_table (archive_id, asset_table)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- 빠른 조회용 집계 캐시 (선택적)
CREATE TABLE archive_summary_cache (
    archive_id INT PRIMARY KEY,
    cash_total BIGINT DEFAULT 0,
    cash_count INT DEFAULT 0,
    investment_total BIGINT DEFAULT 0,
    investment_count INT DEFAULT 0,
    pension_total BIGINT DEFAULT 0,
    pension_count INT DEFAULT 0,
    total_assets BIGINT AS (cash_total + investment_total + pension_total),

    FOREIGN KEY (archive_id) REFERENCES monthly_archives(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

## 🔌 백엔드 API 설계

### 기존 API 보존 + 새로운 Archive API 추가

```php
// 기존 API 그대로 유지
/api/cash-assets          ← 현재 데이터 (변경 없음)
/api/investment-assets    ← 현재 데이터 (변경 없음)
/api/pension-assets       ← 현재 데이터 (변경 없음)

// 새로운 Archive API 추가
/api/archive/months                     ← 아카이브 가능한 월 목록
/api/archive/cash-assets?month=2025-08  ← 특정 월 현금 자산
/api/archive/investment-assets?month=2025-08
/api/archive/pension-assets?month=2025-08

// 아카이브 생성/수정
POST /api/archive/create-snapshot?month=2025-08
PUT  /api/archive/cash-assets/123?month=2025-08
```

### 구현할 파일들

```
backend/
├── api/archive.php              ← 새로운 Archive API 엔드포인트
├── controllers/ArchiveController.php  ← Archive 로직
├── models/MonthlyArchive.php    ← Archive 메인 모델
└── models/ArchiveData.php       ← Archive 데이터 모델
```

## 🎨 프론트엔드 구현 계획

### 1단계: 월 선택기 UI 추가

```html
<!-- assets.php 상단에 추가 -->
<div class="month-selector-container">
    <div class="section-header">
        <h4>조회 기간</h4>
        <div class="month-controls">
            <select id="month-selector" class="browser-default">
                <option value="current" selected>현재 (실시간)</option>
                <!-- 동적으로 아카이브 월 추가 -->
            </select>
            <button id="create-snapshot-btn" class="btn-small blue" style="display:none">
                스냅샷 생성
            </button>
        </div>
    </div>
    <div id="archive-mode-notice" class="card-panel orange lighten-4" style="display:none">
        <i class="material-icons left">archive</i>
        과거 데이터 조회 중 - 수정 시 아카이브가 업데이트됩니다
    </div>
</div>
```

### 2단계: JavaScript 래핑 구조

```javascript
// 기존 함수들 보존
const OriginalAssetAPI = {
    loadCashAssets: window.loadCashAssets,
    loadInvestmentAssets: window.loadInvestmentAssets,
    loadPensionAssets: window.loadPensionAssets,
    // ... 모든 기존 함수들 백업
};

// 새로운 Archive 관리자
class ArchiveManager {
    static currentMode = 'current';
    static selectedMonth = null;

    static getAPIUrl(endpoint) {
        if (this.currentMode === 'current') {
            return 'http://localhost:8080/api/' + endpoint;
        } else {
            return `http://localhost:8080/api/archive/${endpoint}?month=${this.selectedMonth}`;
        }
    }

    static switchMode(month) {
        if (month === 'current') {
            this.currentMode = 'current';
            // 기존 함수들 그대로 호출
            OriginalAssetAPI.loadCashAssets();
            OriginalAssetAPI.loadInvestmentAssets();
            OriginalAssetAPI.loadPensionAssets();
        } else {
            this.currentMode = 'archive';
            this.selectedMonth = month;
            // Archive API로 데이터 로드
            this.loadArchiveData();
        }
    }
}
```

### 3단계: 기존 AJAX 함수 확장

```javascript
// 기존 함수는 그대로 두고, URL만 동적으로 변경
function loadCashAssets() {
    $.ajax({
        url: ArchiveManager.getAPIUrl('cash-assets'),  // ← 이 부분만 변경
        method: 'GET',
        success: function(response) {
            // 기존 로직 그대로 사용
            // ...
        }
    });
}
```

## 📝 구현 단계별 계획

### Phase 1: 데이터베이스 기반 구축 (1-2시간)
- [ ] 새로운 테이블 생성 스크립트 작성
- [ ] 기존 데이터 기반 첫 아카이브 생성 테스트
- [ ] 기본 Archive 모델 클래스 구현

### Phase 2: 백엔드 API 구현 (2-3시간)
- [ ] ArchiveController 기본 구조
- [ ] GET /api/archive/{asset-type} 구현
- [ ] POST /api/archive/create-snapshot 구현
- [ ] PUT /api/archive/{asset-type}/{id} 구현

### Phase 3: 프론트엔드 기본 UI (1시간)
- [ ] 월 선택기 UI 추가 (기존 페이지 수정 최소화)
- [ ] 아카이브 모드 표시 UI
- [ ] 기본 모드 전환 이벤트 핸들러

### Phase 4: API 연동 및 테스트 (2-3시간)
- [ ] ArchiveManager 클래스 구현
- [ ] 기존 AJAX 함수 URL 동적 변경
- [ ] 현재↔아카이브 모드 전환 테스트
- [ ] 아카이브 데이터 수정 기능 테스트

### Phase 5: 완성 및 최적화 (1시간)
- [ ] 로딩 상태 UI 개선
- [ ] 에러 핸들링 추가
- [ ] 모바일 UI 최적화
- [ ] 최종 통합 테스트

## ⚠️ 위험요소 및 대응방안

### 위험요소
1. **기존 JavaScript 함수 충돌**
2. **AJAX 요청 동시성 문제**
3. **UI 상태 불일치**
4. **성능 저하**

### 대응방안
1. **점진적 구현**: 한 번에 하나씩, 테스트하면서
2. **백업 유지**: 모든 기존 함수 원본 보존
3. **롤백 계획**: 문제 발생 시 즉시 이전 상태로 복구
4. **단계별 검증**: 각 단계마다 기존 기능 정상 동작 확인

## 🎯 성공 기준

### 필수 기능
- [ ] 현재 월 데이터 조회 (기존과 동일)
- [ ] 과거 월 아카이브 데이터 조회
- [ ] 아카이브 데이터 수정 기능
- [ ] 월별 스냅샷 생성 기능

### 품질 기준
- [ ] 기존 모든 기능 100% 정상 동작
- [ ] 모바일 UI 정상 작동
- [ ] API 응답 시간 2초 이내
- [ ] JavaScript 에러 발생 없음

## 📚 구현 우선순위

**높음 (필수)**
1. 현금자산 아카이브 기능
2. 월 선택기 UI
3. 기본 아카이브 CRUD

**중간 (중요)**
1. 투자자산 아카이브
2. 연금자산 아카이브
3. 스냅샷 자동 생성

**낮음 (선택)**
1. 집계 캐시 최적화
2. 고급 UI 효과
3. 배치 작업 기능

---

## 💬 구현 방침

이 작업지시서에 따라 **덧붙이기 방식**으로 안전하게 구현하며, 각 단계마다 기존 기능의 정상 동작을 확인합니다. 문제 발생 시 즉시 이전 단계로 되돌릴 수 있도록 진행합니다.